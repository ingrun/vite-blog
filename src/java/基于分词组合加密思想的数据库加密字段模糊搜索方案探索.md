# 基于分词组合加密思想的数据库加密字段模糊搜索方案探索
## 摘要

当前，数据库字段的加密搜索技术仍处于探索阶段。现有的主要实现方案包括：对数据库进行全局解密后检索、将数据查询后在内存中解密后再检索，以及分词组合加密（即先对明文进行分词处理，再加密并存储），查询时，通过匹配分词结果来实现搜索功能。然而，这些方法存在明显的局限性：全局解密可能需要消耗大量计算资源和时间，可能导致延迟，影响用户体验。内存解密内存容量有限，无法同时加载和解密大规模数据，攻击者可以通过内存扫描工具（如调试器或恶意软件）直接读取内存中的解密数据，而分词组合加密，为确保搜索体验，需要穷举所有可能的分词组合，这使得存储和检索成本随着字段长度的增加而呈指数级增长。针对这一问题，本文提出了一些优化思路，通过在功能性或安全性方面做出适当调整，从而大幅提升其实用性和可行性。

## 正文

目前，主流的数据库字段加密搜索方式主要依赖于分词组合加密技术。具体而言，该方法会将密文按照不同长度进行分词处理，然后对这些分词进行加密并保存。在查询阶段，系统会将用户提供的查询语句与分词结果进行匹配。然而，这一方案也存在一定的局限性：为了实现良好的搜索体验，需要穷举所有可能的组合，这会导致存储成本和检索成本大幅增加，并且随着字段长度的增长，这种成本将以指数级增长。

针对这一问题，我对该方案进行了优化，通过调整其安全性和功能性，显著提升了方案的可行性。

### 一、限制功能性以提升性能，降低存储成本

具体来说，不再穷举所有可能的组合，而是仅选取较大概率会被使用的组合进行加密。例如，我们可以选择手机号的前三位和后四位作为加密的目标字段，因为这些部分通常具有较高的识别度，并且能够满足大多数场景下的需求。这种策略可以有效减少需要处理的数据量，同时仍然保留了足够的信息用于后续操作。

此外，还可以进一步限制匹配模式以优化性能。例如，我们仅支持左匹配的方式，这意味着系统只会考虑从字符串左侧开始的部分进行比对，而忽略其他位置的可能性。这样的设计不仅能够大幅减少潜在的组合数量，还能够显著降低存储和计算开销，从而提升整体效率。在实际应用中，这种方法尤其适用于那些对性能要求较高但对精确度有一定容忍范围的场景，比如大规模数据筛选或初步过滤阶段。通过上述方法，我们可以在保证功能可用性的前提下，有效地简化加密过程并节省资源。

### 二、降低安全性以实现直接检索

现有的数据加密通常采用成熟的加密算法，这些算法虽然具备较高的安全性，但无法直接支持搜索功能，甚至部分加密算法对同一数据加密后的密文可能不一致。为了解决这一问题，我们可以设计一种自定义加密算法，使其生成的密文能够被检索。可以借鉴块加密的思想，对单个字符逐一加密并将结果拼接成完整的密文。这样一来，在检索时，只需对目标部分密文进行加密，其结果必定是完整密文的子串，从而实现了低成本的任意搜索功能。

通过上述优化，既能在一定程度上满足安全性需求，又能显著降低存储和检索成本，同时提升搜索效率。

```java

public class CustomEncryptor {

    private static String SALT1 = "";
    private static String SALT2 = "";
    private static final int FIXED_LENGTH = 12; // 截断为固定长度十六进制字符串

    public static void setSALT1(String SALT1) {
        CustomEncryptor.SALT1 = SALT1;
    }

    public static void setSALT2(String SALT2) {
        CustomEncryptor.SALT2 = SALT2;
    }

    // 单字符加密函数
    public static String encryptChar(char c) {
        try {
            // 第一层哈希：字符 + SALT1
            String hash1 = hash(c + SALT1 + (int) c);
            // 第二层哈希：hash1 + SALT2
            String hash2 = hash(hash1 + (int) c + SALT2);
            // 截断为固定长度（前8位）
            return hash2.substring(0, FIXED_LENGTH);
        } catch (Exception e) {
            throw new RuntimeException("加密失败", e);
        }
    }

    // 整体加密函数（直接拼接单字符加密结果）
    public static String encrypt(String input) {
        StringBuilder encrypted = new StringBuilder();
        for (char c : input.toCharArray()) {
            encrypted.append(encryptChar(c));
        }
        return encrypted.toString();
    }

    // 辅助方法：SHA-256哈希
    private static String hash(String input) throws Exception {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hashBytes = digest.digest(input.getBytes());
        return bytesToHex(hashBytes);
    }

    // 辅助方法：字节转十六进制字符串
    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }
}

```

以上自定义算法是通过将每个字符进行两层哈希处理，并最终截取固定长度的十六进制字符串来实现加密的。工作流程初始化涉及到两个静态字符串变量，称为 SALT1 和 SALT2，它们用于在哈希过程中增加额外的随机性。你可以通过调用 setSALT1 和 setSALT2 方法来设置这些盐值。当需要加密输入字符串中的每一个字符时，过程如下：首先，将字符与 SALT1 以及它的 ASCII 码值拼接在一起，然后进行第一轮 SHA-256 哈希；接着，把第一次哈希的结果再次与字符的 ASCII 码值和 SALT2 拼接，进行第二轮 SHA-256 哈希。最后，从第二次哈希的结果中截取指定长度作为该字符的加密输出。

对于整个字符串的加密，系统会遍历输入字符串中的每个字符，并调用上述的单字符加密方法。之后，它会将所有字符的加密结果按照原来的顺序连接起来，形成最终的加密字符串。此外，还存在一些辅助的方法，例如 hash 方法用于执行 SHA-256 哈希运算，而 bytesToHex 方法则负责将字节数组转换成十六进制字符串表示形式。

关于盐值的选择，它们在这里扮演着类似密钥的角色，因此选择和保护盐值都非常重要。为了保证同一数据每次加密的结果相同，必须保持盐值不变。建议第一个盐值采用固定的全局值，而第二个盐值可以根据要加密的字段来确定，比如通过反射获取字段名称并附加其他字符，以确保不同字段有不同的盐值，从而增强安全性。同时，考虑到安全性和存储成本之间的平衡，可以适当地调整哈希结果截取的长度。

### 三、综合加密算法与搜索算法

前文提到的自定义算法存在一个显著问题，即采用逐个字符加密的方式，这种方式容易受到彩虹表攻击的影响。为了解决这一隐患，可以将加密方法与搜索方法相结合，从而有效规避上述风险。

在加密过程中，仍沿用原有的加密逻辑，但需调整为非逐个字符的加密方式。具体而言，可将数据分割为指定长度的块（例如长度为2或3的块），对每个块分别进行加密，最后将加密后的块组合成最终的密文。

在搜索阶段，若加密块的长度为2，而搜索值的长度为3，则可提取搜索值的前两位进行匹配。如果搜索结果为空，应移除搜索值的第一位字符后再次进行搜索。这种机制能够避免类似“1234”被分块为“12”和“34”时，因搜索“23”而导致搜索失败的问题。此外，在加密不同数据时，还可以动态调整块的长度，使生成的密文更难以预测，从而从根本上抵御彩虹表攻击的威胁。该方案是上述两方案的结合，虽实现有一定的复杂度但也大大提升了安全性。

## 结论

综上所述，当前主数据库字段的加密搜索技术虽然已经取得了一定进展，但仍面临着诸多挑战，特别是在性能、存储成本及安全性之间的平衡方面。现有的分词组合加密方法尽管提供了一种可行的解决方案，但其局限性不可忽视：全局解密和内存解密方案不仅消耗大量资源，而且存在安全隐患；而分词组合加密虽然能够在一定程度上满足搜索需求，但随着字段长度的增长，其存储和检索成本呈指数级上升，严重制约了实际应用。

通过对现有方案的功能性和安全性进行适当调整，本文提出的优化措施旨在解决这些问题。一方面，通过限制功能性，如减少分词组合的数量和支持特定匹配模式，可以有效降低存储和计算开销，提高搜索性能；另一方面，设计一种新的自定义加密算法，使生成的密文既能保持一定安全性，又可以直接支持搜索功能，从而在保证数据安全的前提下，显著提升搜索效率和用户体验。

总的来说，这些优化措施不仅在理论上具有创新性，而且在实践中也展示了良好的可行性和实用性，为未来数据库字段加密搜索技术的发展提供了新的思路和方向。然而，值得注意的是，任何安全性的降低都需要谨慎评估风险，并确保在可接受的安全范围内进行调整，以避免潜在的数据泄露或其他安全问题。因此，在实际应用中，应根据具体场景的需求，权衡安全性和性能之间的关系，选择最合适的解决方案。